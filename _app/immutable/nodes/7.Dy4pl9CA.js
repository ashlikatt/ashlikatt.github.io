import{s as xe,n as Se}from"../chunks/scheduler.DrUr7rw5.js";import{S as et,i as tt,e as S,t as r,c as A,a as st,b as o,d as n,k as $t,g as s,h as it,j as lt,o as w,s as X,p as h,f as Z,q as k,m as v,n as B,r as N}from"../chunks/index.BfAMNwJz.js";import{P as at,H as rt}from"../chunks/pageData.CqP318gz.js";import{B as ot,P as _e}from"../chunks/paragraph.C2yhdLRw.js";import{D as ft}from"../chunks/deprecated_header.C_sesCB6.js";import{C as nt}from"../chunks/comment.Cdy7g4I7.js";import{E as mt}from"../chunks/externalLink.DNJPPYHb.js";import{I as j}from"../chunks/inlineCode.BRCHcj98.js";import{S as be}from"../chunks/section.nWrM8mab.js";function pt(a){let t,e=a[0].split(`
`).map(Ze).join(`
`)+"",i;return{c(){t=S("p"),i=r(e),this.h()},l(d){t=A(d,"P",{class:!0});var b=st(t);i=o(b,e),b.forEach(n),this.h()},h(){$t(t,"class","svelte-1y4hdci")},m(d,b){s(d,t,b),it(t,i)},p(d,[b]){b&1&&e!==(e=d[0].split(`
`).map(Ze).join(`
`)+"")&&lt(i,e)},i:Se,o:Se,d(d){d&&n(t)}}}const Ze=a=>a.trimStart().substring(1);function ut(a,t,e){let{value:i}=t;return a.$$set=d=>{"value"in d&&e(0,i=d.value)},[i]}class Ae extends et{constructor(t){super(),tt(this,t,ut,pt,xe,{value:0})}}function ct(a){let t;return{c(){t=r("Back")},l(e){t=o(e,"Back")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function _t(a){let t,e;return t=new rt({props:{href:"langs/dfon",$$slots:{default:[ct]},$$scope:{ctx:a}}}),{c(){w(t.$$.fragment)},l(i){h(t.$$.fragment,i)},m(i,d){k(t,i,d),e=!0},p(i,d){const b={};d&1&&(b.$$scope={dirty:d,ctx:i}),t.$set(b)},i(i){e||(v(t.$$.fragment,i),e=!0)},o(i){B(t.$$.fragment,i),e=!1},d(i){N(t,i)}}}function bt(a){let t;return{c(){t=r("JSON")},l(e){t=o(e,"JSON")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function gt(a){let t;return{c(){t=r("I mean it!!")},l(e){t=o(e,"I mean it!!")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function dt(a){let t,e,i,d,b,I,R,y;return b=new mt({props:{href:"https://www.json.org/json-en.html",$$slots:{default:[bt]},$$scope:{ctx:a}}}),R=new nt({props:{$$slots:{default:[gt]},$$scope:{ctx:a}}}),{c(){t=r(`DiamondFire Object Notation is a JSON-like language for constant data on DiamondFire plots. It is not a programming language.
        DFON was created to streamline the production of games with large amounts of constant, read-only data. It may be helpful for things like weapon stats,
        map regions, npc dialogue, etc.`),e=S("br"),i=S("br"),d=r(`

        It is recommended to have an understanding of `),w(b.$$.fragment),I=r(`
        before using DFON, as they share many similarities. `),w(R.$$.fragment)},l(p){t=o(p,`DiamondFire Object Notation is a JSON-like language for constant data on DiamondFire plots. It is not a programming language.
        DFON was created to streamline the production of games with large amounts of constant, read-only data. It may be helpful for things like weapon stats,
        map regions, npc dialogue, etc.`),e=A(p,"BR",{}),i=A(p,"BR",{}),d=o(p,`

        It is recommended to have an understanding of `),h(b.$$.fragment,p),I=o(p,`
        before using DFON, as they share many similarities. `),h(R.$$.fragment,p)},m(p,T){s(p,t,T),s(p,e,T),s(p,i,T),s(p,d,T),k(b,p,T),s(p,I,T),k(R,p,T),y=!0},p(p,T){const P={};T&1&&(P.$$scope={dirty:T,ctx:p}),b.$set(P);const W={};T&1&&(W.$$scope={dirty:T,ctx:p}),R.$set(W)},i(p){y||(v(b.$$.fragment,p),v(R.$$.fragment,p),y=!0)},o(p){B(b.$$.fragment,p),B(R.$$.fragment,p),y=!1},d(p){p&&(n(t),n(e),n(i),n(d),n(I)),N(b,p),N(R,p)}}}function wt(a){let t;return{c(){t=r("Basic Structure")},l(e){t=o(e,"Basic Structure")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function ht(a){let t;return{c(){t=r("With the corresponding name and value")},l(e){t=o(e,"With the corresponding name and value")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function kt(a){let t;return{c(){t=r("a")},l(e){t=o(e,"a")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function vt(a){let t;return{c(){t=r("b")},l(e){t=o(e,"b")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Bt(a){let t;return{c(){t=r("c")},l(e){t=o(e,"c")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Nt(a){let t;return{c(){t=r("key")},l(e){t=o(e,"key")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Rt(a){let t,e,i,d,b,I,R,y,p,T,P,W,J,z,L,E,M,U,C,Y,V,q;return b=new nt({props:{$$slots:{default:[ht]},$$scope:{ctx:a}}}),R=new Ae({props:{value:`            |{
            |        a: 0,
            |        b: 1,
            |        c: [1, 2, 3],
            |    "key": "whatever",
            |}
        `}}),p=new j({props:{$$slots:{default:[kt]},$$scope:{ctx:a}}}),P=new j({props:{$$slots:{default:[vt]},$$scope:{ctx:a}}}),J=new j({props:{$$slots:{default:[Bt]},$$scope:{ctx:a}}}),L=new j({props:{$$slots:{default:[Nt]},$$scope:{ctx:a}}}),{c(){t=r(`A DFON file uses the same rough structure as JSON. The file is one huge dictionary, which has 0 or more keys.
        Those keys contain other values like lists, strings, numbers, nested dictionaries, etc.`),e=S("br"),i=S("br"),d=r(`

        The outer-most dictionary is referred to as the "main dictionary." When DFON is compiled, each entry in the main dictionary will become a global variable. 
        `),w(b.$$.fragment),I=X(),w(R.$$.fragment),y=r(`

        This will compile down into a code-line that sets the global variables `),w(p.$$.fragment),T=r(", "),w(P.$$.fragment),W=r(`, 
        `),w(J.$$.fragment),z=r(", and "),w(L.$$.fragment),E=r(" to their respective values."),M=S("br"),U=S("br"),C=r(`

        Both strings and identifiers are allowed as keys for a dictionary, and trailing commas are allowed anywhere.`),Y=S("br"),V=r(`
        Values will be covered in the following three sections.`)},l(c){t=o(c,`A DFON file uses the same rough structure as JSON. The file is one huge dictionary, which has 0 or more keys.
        Those keys contain other values like lists, strings, numbers, nested dictionaries, etc.`),e=A(c,"BR",{}),i=A(c,"BR",{}),d=o(c,`

        The outer-most dictionary is referred to as the "main dictionary." When DFON is compiled, each entry in the main dictionary will become a global variable. 
        `),h(b.$$.fragment,c),I=Z(c),h(R.$$.fragment,c),y=o(c,`

        This will compile down into a code-line that sets the global variables `),h(p.$$.fragment,c),T=o(c,", "),h(P.$$.fragment,c),W=o(c,`, 
        `),h(J.$$.fragment,c),z=o(c,", and "),h(L.$$.fragment,c),E=o(c," to their respective values."),M=A(c,"BR",{}),U=A(c,"BR",{}),C=o(c,`

        Both strings and identifiers are allowed as keys for a dictionary, and trailing commas are allowed anywhere.`),Y=A(c,"BR",{}),V=o(c,`
        Values will be covered in the following three sections.`)},m(c,f){s(c,t,f),s(c,e,f),s(c,i,f),s(c,d,f),k(b,c,f),s(c,I,f),k(R,c,f),s(c,y,f),k(p,c,f),s(c,T,f),k(P,c,f),s(c,W,f),k(J,c,f),s(c,z,f),k(L,c,f),s(c,E,f),s(c,M,f),s(c,U,f),s(c,C,f),s(c,Y,f),s(c,V,f),q=!0},p(c,f){const D={};f&1&&(D.$$scope={dirty:f,ctx:c}),b.$set(D);const G={};f&1&&(G.$$scope={dirty:f,ctx:c}),p.$set(G);const H={};f&1&&(H.$$scope={dirty:f,ctx:c}),P.$set(H);const Q={};f&1&&(Q.$$scope={dirty:f,ctx:c}),J.$set(Q);const u={};f&1&&(u.$$scope={dirty:f,ctx:c}),L.$set(u)},i(c){q||(v(b.$$.fragment,c),v(R.$$.fragment,c),v(p.$$.fragment,c),v(P.$$.fragment,c),v(J.$$.fragment,c),v(L.$$.fragment,c),q=!0)},o(c){B(b.$$.fragment,c),B(R.$$.fragment,c),B(p.$$.fragment,c),B(P.$$.fragment,c),B(J.$$.fragment,c),B(L.$$.fragment,c),q=!1},d(c){c&&(n(t),n(e),n(i),n(d),n(I),n(y),n(T),n(W),n(z),n(E),n(M),n(U),n(C),n(Y),n(V)),N(b,c),N(R,c),N(p,c),N(P,c),N(J,c),N(L,c)}}}function Dt(a){let t;return{c(){t=r("Basic Primitive Types")},l(e){t=o(e,"Basic Primitive Types")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Ft(a){let t;return{c(){t=r("0x")},l(e){t=o(e,"0x")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Tt(a){let t;return{c(){t=r("0o")},l(e){t=o(e,"0o")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Ot(a){let t;return{c(){t=r("0b")},l(e){t=o(e,"0b")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function yt(a){let t;return{c(){t=r("12")},l(e){t=o(e,"12")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function St(a){let t;return{c(){t=r("-12")},l(e){t=o(e,"-12")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function At(a){let t;return{c(){t=r("12.52")},l(e){t=o(e,"12.52")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function It(a){let t;return{c(){t=r("-1_000_000_000.002")},l(e){t=o(e,"-1_000_000_000.002")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Pt(a){let t;return{c(){t=r("0xFF_00_AA")},l(e){t=o(e,"0xFF_00_AA")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Ct(a){let t;return{c(){t=r("-0b11101110")},l(e){t=o(e,"-0b11101110")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function jt(a){let t;return{c(){t=r("0o77")},l(e){t=o(e,"0o77")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Vt(a){let t;return{c(){t=r('"')},l(e){t=o(e,'"')},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Wt(a){let t;return{c(){t=r("'")},l(e){t=o(e,"'")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Jt(a){let t;return{c(){t=r("T")},l(e){t=o(e,"T")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Lt(a){let t;return{c(){t=r('""')},l(e){t=o(e,'""')},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Mt(a){let t;return{c(){t=r('"Hello, World!"')},l(e){t=o(e,'"Hello, World!"')},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function zt(a){let t;return{c(){t=r('"String that has \\na newline!"')},l(e){t=o(e,'"String that has \\na newline!"')},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function qt(a){let t;return{c(){t=r('T""')},l(e){t=o(e,'T""')},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Ht(a){let t;return{c(){t=r('T"<red>Hello, player!"')},l(e){t=o(e,'T"<red>Hello, player!"')},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Et(a){let t;return{c(){t=r('"Text that has <newline>a newline!"')},l(e){t=o(e,'"Text that has <newline>a newline!"')},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Ut(a){let t,e,i,d,b,I,R,y,p,T,P,W,J,z,L,E,M,U,C,Y,V,q,c,f,D,G,H,Q,u,O,K,ne,x,se,ee,m,F,ie,te,le,l,g,ue,ce,$e,ge,de,we,he,ae,ke,re,ve,oe,Be,Ne,fe,Re,me,De,pe,Fe,Te,Oe,ye;return T=new j({props:{$$slots:{default:[Ft]},$$scope:{ctx:a}}}),W=new j({props:{$$slots:{default:[Tt]},$$scope:{ctx:a}}}),z=new j({props:{$$slots:{default:[Ot]},$$scope:{ctx:a}}}),C=new j({props:{$$slots:{default:[yt]},$$scope:{ctx:a}}}),V=new j({props:{$$slots:{default:[St]},$$scope:{ctx:a}}}),c=new j({props:{$$slots:{default:[At]},$$scope:{ctx:a}}}),D=new j({props:{$$slots:{default:[It]},$$scope:{ctx:a}}}),H=new j({props:{$$slots:{default:[Pt]},$$scope:{ctx:a}}}),u=new j({props:{$$slots:{default:[Ct]},$$scope:{ctx:a}}}),K=new j({props:{$$slots:{default:[jt]},$$scope:{ctx:a}}}),te=new j({props:{$$slots:{default:[Vt]},$$scope:{ctx:a}}}),l=new j({props:{$$slots:{default:[Wt]},$$scope:{ctx:a}}}),$e=new j({props:{$$slots:{default:[Jt]},$$scope:{ctx:a}}}),ae=new j({props:{$$slots:{default:[Lt]},$$scope:{ctx:a}}}),re=new j({props:{$$slots:{default:[Mt]},$$scope:{ctx:a}}}),oe=new j({props:{$$slots:{default:[zt]},$$scope:{ctx:a}}}),fe=new j({props:{$$slots:{default:[qt]},$$scope:{ctx:a}}}),me=new j({props:{$$slots:{default:[Ht]},$$scope:{ctx:a}}}),pe=new j({props:{$$slots:{default:[Et]},$$scope:{ctx:a}}}),{c(){t=r("DFON has the common primitive value types from DiamondFire. This includes numbers, strings, text, locations, and vectors."),e=S("br"),i=r(`
        Numbers, strings, and text are covered in this section. The rest are covered in the next section.`),d=S("br"),b=S("br"),I=r(`

        Numbers are written in base-10, with or without a negative sign, and with or without a decimal place. 
        A number's decimal place may go beyond 3 digits, unlike in DiamondFire - however the value will be truncated when compiling.
        Numbers additionally can have underscores anywhere inside of them for readability`),R=S("br"),y=S("br"),p=r(`

        Numbers may also be written in hex, octal, or binary using the `),w(T.$$.fragment),P=r(", "),w(W.$$.fragment),J=r(`,
        and `),w(z.$$.fragment),L=r(" prefixes. Numbers created this way do not support decimals."),E=S("br"),M=S("br"),U=r(`

        All of the following are valid numbers: `),w(C.$$.fragment),Y=r(", "),w(V.$$.fragment),q=r(", "),w(c.$$.fragment),f=r(`,
        `),w(D.$$.fragment),G=r(", "),w(H.$$.fragment),Q=r(", "),w(u.$$.fragment),O=r(", "),w(K.$$.fragment),ne=r("."),x=S("br"),se=S("br"),ee=X(),m=S("br"),F=S("br"),ie=r(`

        Strings are identical to JSON strings, except they can use either `),w(te.$$.fragment),le=r(`
        or `),w(l.$$.fragment),g=r(" as a delimiter. Backslashes are used to escape characters."),ue=S("br"),ce=r(`
        Text is created by placing `),w($e.$$.fragment),ge=r(" before string quotes."),de=S("br"),we=S("br"),he=r(`

        The following are valid strings: `),w(ae.$$.fragment),ke=r(", "),w(re.$$.fragment),ve=r(`, 
        `),w(oe.$$.fragment),Be=S("br"),Ne=r(`
        The following are valid text: `),w(fe.$$.fragment),Re=r(", "),w(me.$$.fragment),De=r(`, 
        `),w(pe.$$.fragment),Fe=S("br"),Te=S("br"),Oe=r(`

        Remember that this is constant data! DiamondFire Codes like %default have no meaning.`)},l($){t=o($,"DFON has the common primitive value types from DiamondFire. This includes numbers, strings, text, locations, and vectors."),e=A($,"BR",{}),i=o($,`
        Numbers, strings, and text are covered in this section. The rest are covered in the next section.`),d=A($,"BR",{}),b=A($,"BR",{}),I=o($,`

        Numbers are written in base-10, with or without a negative sign, and with or without a decimal place. 
        A number's decimal place may go beyond 3 digits, unlike in DiamondFire - however the value will be truncated when compiling.
        Numbers additionally can have underscores anywhere inside of them for readability`),R=A($,"BR",{}),y=A($,"BR",{}),p=o($,`

        Numbers may also be written in hex, octal, or binary using the `),h(T.$$.fragment,$),P=o($,", "),h(W.$$.fragment,$),J=o($,`,
        and `),h(z.$$.fragment,$),L=o($," prefixes. Numbers created this way do not support decimals."),E=A($,"BR",{}),M=A($,"BR",{}),U=o($,`

        All of the following are valid numbers: `),h(C.$$.fragment,$),Y=o($,", "),h(V.$$.fragment,$),q=o($,", "),h(c.$$.fragment,$),f=o($,`,
        `),h(D.$$.fragment,$),G=o($,", "),h(H.$$.fragment,$),Q=o($,", "),h(u.$$.fragment,$),O=o($,", "),h(K.$$.fragment,$),ne=o($,"."),x=A($,"BR",{}),se=A($,"BR",{}),ee=Z($),m=A($,"BR",{}),F=A($,"BR",{}),ie=o($,`

        Strings are identical to JSON strings, except they can use either `),h(te.$$.fragment,$),le=o($,`
        or `),h(l.$$.fragment,$),g=o($," as a delimiter. Backslashes are used to escape characters."),ue=A($,"BR",{}),ce=o($,`
        Text is created by placing `),h($e.$$.fragment,$),ge=o($," before string quotes."),de=A($,"BR",{}),we=A($,"BR",{}),he=o($,`

        The following are valid strings: `),h(ae.$$.fragment,$),ke=o($,", "),h(re.$$.fragment,$),ve=o($,`, 
        `),h(oe.$$.fragment,$),Be=A($,"BR",{}),Ne=o($,`
        The following are valid text: `),h(fe.$$.fragment,$),Re=o($,", "),h(me.$$.fragment,$),De=o($,`, 
        `),h(pe.$$.fragment,$),Fe=A($,"BR",{}),Te=A($,"BR",{}),Oe=o($,`

        Remember that this is constant data! DiamondFire Codes like %default have no meaning.`)},m($,_){s($,t,_),s($,e,_),s($,i,_),s($,d,_),s($,b,_),s($,I,_),s($,R,_),s($,y,_),s($,p,_),k(T,$,_),s($,P,_),k(W,$,_),s($,J,_),k(z,$,_),s($,L,_),s($,E,_),s($,M,_),s($,U,_),k(C,$,_),s($,Y,_),k(V,$,_),s($,q,_),k(c,$,_),s($,f,_),k(D,$,_),s($,G,_),k(H,$,_),s($,Q,_),k(u,$,_),s($,O,_),k(K,$,_),s($,ne,_),s($,x,_),s($,se,_),s($,ee,_),s($,m,_),s($,F,_),s($,ie,_),k(te,$,_),s($,le,_),k(l,$,_),s($,g,_),s($,ue,_),s($,ce,_),k($e,$,_),s($,ge,_),s($,de,_),s($,we,_),s($,he,_),k(ae,$,_),s($,ke,_),k(re,$,_),s($,ve,_),k(oe,$,_),s($,Be,_),s($,Ne,_),k(fe,$,_),s($,Re,_),k(me,$,_),s($,De,_),k(pe,$,_),s($,Fe,_),s($,Te,_),s($,Oe,_),ye=!0},p($,_){const Ie={};_&1&&(Ie.$$scope={dirty:_,ctx:$}),T.$set(Ie);const Pe={};_&1&&(Pe.$$scope={dirty:_,ctx:$}),W.$set(Pe);const Ce={};_&1&&(Ce.$$scope={dirty:_,ctx:$}),z.$set(Ce);const je={};_&1&&(je.$$scope={dirty:_,ctx:$}),C.$set(je);const Ve={};_&1&&(Ve.$$scope={dirty:_,ctx:$}),V.$set(Ve);const We={};_&1&&(We.$$scope={dirty:_,ctx:$}),c.$set(We);const Je={};_&1&&(Je.$$scope={dirty:_,ctx:$}),D.$set(Je);const Le={};_&1&&(Le.$$scope={dirty:_,ctx:$}),H.$set(Le);const Me={};_&1&&(Me.$$scope={dirty:_,ctx:$}),u.$set(Me);const ze={};_&1&&(ze.$$scope={dirty:_,ctx:$}),K.$set(ze);const qe={};_&1&&(qe.$$scope={dirty:_,ctx:$}),te.$set(qe);const He={};_&1&&(He.$$scope={dirty:_,ctx:$}),l.$set(He);const Ee={};_&1&&(Ee.$$scope={dirty:_,ctx:$}),$e.$set(Ee);const Ue={};_&1&&(Ue.$$scope={dirty:_,ctx:$}),ae.$set(Ue);const Ye={};_&1&&(Ye.$$scope={dirty:_,ctx:$}),re.$set(Ye);const Ge={};_&1&&(Ge.$$scope={dirty:_,ctx:$}),oe.$set(Ge);const Ke={};_&1&&(Ke.$$scope={dirty:_,ctx:$}),fe.$set(Ke);const Qe={};_&1&&(Qe.$$scope={dirty:_,ctx:$}),me.$set(Qe);const Xe={};_&1&&(Xe.$$scope={dirty:_,ctx:$}),pe.$set(Xe)},i($){ye||(v(T.$$.fragment,$),v(W.$$.fragment,$),v(z.$$.fragment,$),v(C.$$.fragment,$),v(V.$$.fragment,$),v(c.$$.fragment,$),v(D.$$.fragment,$),v(H.$$.fragment,$),v(u.$$.fragment,$),v(K.$$.fragment,$),v(te.$$.fragment,$),v(l.$$.fragment,$),v($e.$$.fragment,$),v(ae.$$.fragment,$),v(re.$$.fragment,$),v(oe.$$.fragment,$),v(fe.$$.fragment,$),v(me.$$.fragment,$),v(pe.$$.fragment,$),ye=!0)},o($){B(T.$$.fragment,$),B(W.$$.fragment,$),B(z.$$.fragment,$),B(C.$$.fragment,$),B(V.$$.fragment,$),B(c.$$.fragment,$),B(D.$$.fragment,$),B(H.$$.fragment,$),B(u.$$.fragment,$),B(K.$$.fragment,$),B(te.$$.fragment,$),B(l.$$.fragment,$),B($e.$$.fragment,$),B(ae.$$.fragment,$),B(re.$$.fragment,$),B(oe.$$.fragment,$),B(fe.$$.fragment,$),B(me.$$.fragment,$),B(pe.$$.fragment,$),ye=!1},d($){$&&(n(t),n(e),n(i),n(d),n(b),n(I),n(R),n(y),n(p),n(P),n(J),n(L),n(E),n(M),n(U),n(Y),n(q),n(f),n(G),n(Q),n(O),n(ne),n(x),n(se),n(ee),n(m),n(F),n(ie),n(le),n(g),n(ue),n(ce),n(ge),n(de),n(we),n(he),n(ke),n(ve),n(Be),n(Ne),n(Re),n(De),n(Fe),n(Te),n(Oe)),N(T,$),N(W,$),N(z,$),N(C,$),N(V,$),N(c,$),N(D,$),N(H,$),N(u,$),N(K,$),N(te,$),N(l,$),N($e,$),N(ae,$),N(re,$),N(oe,$),N(fe,$),N(me,$),N(pe,$)}}}function Yt(a){let t;return{c(){t=r("Other Primitive Types")},l(e){t=o(e,"Other Primitive Types")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Gt(a){let t;return{c(){t=r("(1, 2, 3)")},l(e){t=o(e,"(1, 2, 3)")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Kt(a){let t;return{c(){t=r("(23.5, 50.5, 24.5, )")},l(e){t=o(e,"(23.5, 50.5, 24.5, )")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Qt(a){let t;return{c(){t=r("(150.5, 200.5, 150.5, 0, 90, )")},l(e){t=o(e,"(150.5, 200.5, 150.5, 0, 90, )")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Xt(a){let t;return{c(){t=r("<2, 3, 4>")},l(e){t=o(e,"<2, 3, 4>")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Zt(a){let t;return{c(){t=r("<1, 0.25, 0, >")},l(e){t=o(e,"<1, 0.25, 0, >")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function xt(a){let t,e,i,d,b,I,R,y,p,T,P,W,J,z,L,E,M,U,C,Y,V,q,c;return b=new j({props:{$$slots:{default:[Gt]},$$scope:{ctx:a}}}),R=new j({props:{$$slots:{default:[Kt]},$$scope:{ctx:a}}}),p=new j({props:{$$slots:{default:[Qt]},$$scope:{ctx:a}}}),C=new j({props:{$$slots:{default:[Xt]},$$scope:{ctx:a}}}),V=new j({props:{$$slots:{default:[Zt]},$$scope:{ctx:a}}}),{c(){t=r("Locations are written as 3 or 5 comma-separated numbers inside of parenthesis."),e=S("br"),i=S("br"),d=r(`
        Valid locations may look like: `),w(b.$$.fragment),I=r(", "),w(R.$$.fragment),y=r(`, or 
        `),w(p.$$.fragment),T=r("."),P=S("br"),W=S("br"),J=S("br"),z=S("br"),L=r(`

        Vectors are written as 3 comma-separated numbers inside of parenthesis.`),E=S("br"),M=S("br"),U=r(`
        Valid vectors may look like: `),w(C.$$.fragment),Y=r(" or "),w(V.$$.fragment),q=r(".")},l(f){t=o(f,"Locations are written as 3 or 5 comma-separated numbers inside of parenthesis."),e=A(f,"BR",{}),i=A(f,"BR",{}),d=o(f,`
        Valid locations may look like: `),h(b.$$.fragment,f),I=o(f,", "),h(R.$$.fragment,f),y=o(f,`, or 
        `),h(p.$$.fragment,f),T=o(f,"."),P=A(f,"BR",{}),W=A(f,"BR",{}),J=A(f,"BR",{}),z=A(f,"BR",{}),L=o(f,`

        Vectors are written as 3 comma-separated numbers inside of parenthesis.`),E=A(f,"BR",{}),M=A(f,"BR",{}),U=o(f,`
        Valid vectors may look like: `),h(C.$$.fragment,f),Y=o(f," or "),h(V.$$.fragment,f),q=o(f,".")},m(f,D){s(f,t,D),s(f,e,D),s(f,i,D),s(f,d,D),k(b,f,D),s(f,I,D),k(R,f,D),s(f,y,D),k(p,f,D),s(f,T,D),s(f,P,D),s(f,W,D),s(f,J,D),s(f,z,D),s(f,L,D),s(f,E,D),s(f,M,D),s(f,U,D),k(C,f,D),s(f,Y,D),k(V,f,D),s(f,q,D),c=!0},p(f,D){const G={};D&1&&(G.$$scope={dirty:D,ctx:f}),b.$set(G);const H={};D&1&&(H.$$scope={dirty:D,ctx:f}),R.$set(H);const Q={};D&1&&(Q.$$scope={dirty:D,ctx:f}),p.$set(Q);const u={};D&1&&(u.$$scope={dirty:D,ctx:f}),C.$set(u);const O={};D&1&&(O.$$scope={dirty:D,ctx:f}),V.$set(O)},i(f){c||(v(b.$$.fragment,f),v(R.$$.fragment,f),v(p.$$.fragment,f),v(C.$$.fragment,f),v(V.$$.fragment,f),c=!0)},o(f){B(b.$$.fragment,f),B(R.$$.fragment,f),B(p.$$.fragment,f),B(C.$$.fragment,f),B(V.$$.fragment,f),c=!1},d(f){f&&(n(t),n(e),n(i),n(d),n(I),n(y),n(T),n(P),n(W),n(J),n(z),n(L),n(E),n(M),n(U),n(Y),n(q)),N(b,f),N(R,f),N(p,f),N(C,f),N(V,f)}}}function en(a){let t;return{c(){t=r("Compound Types")},l(e){t=o(e,"Compound Types")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function tn(a){let t;return{c(){t=r("[]")},l(e){t=o(e,"[]")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function nn(a){let t;return{c(){t=r("[2]")},l(e){t=o(e,"[2]")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function sn(a){let t;return{c(){t=r('["a", 2, { a: 2 }, ]')},l(e){t=o(e,'["a", 2, { a: 2 }, ]')},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function $n(a){let t;return{c(){t=r("{}")},l(e){t=o(e,"{}")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function ln(a){let t;return{c(){t=r("{ a: 2 }")},l(e){t=o(e,"{ a: 2 }")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function an(a){let t;return{c(){t=r("{ a: 2, b: { c: 3 }, }")},l(e){t=o(e,"{ a: 2, b: { c: 3 }, }")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function rn(a){let t,e,i,d,b,I,R,y,p,T,P,W,J,z,L,E,M,U,C,Y,V,q,c,f,D,G,H,Q;return R=new j({props:{$$slots:{default:[tn]},$$scope:{ctx:a}}}),p=new j({props:{$$slots:{default:[nn]},$$scope:{ctx:a}}}),P=new j({props:{$$slots:{default:[sn]},$$scope:{ctx:a}}}),q=new j({props:{$$slots:{default:[$n]},$$scope:{ctx:a}}}),f=new j({props:{$$slots:{default:[ln]},$$scope:{ctx:a}}}),G=new j({props:{$$slots:{default:[an]},$$scope:{ctx:a}}}),{c(){t=r("DFON has the same two compound types as JSON, dictionaries and lists."),e=S("br"),i=r(`
        
        Lists are written as square brackets with zero or more comma-separated values inside. 
        When compiled, they become a DiamondFire List value.`),d=S("br"),b=S("br"),I=r(`

        Valid lists may look like `),w(R.$$.fragment),y=r(", "),w(p.$$.fragment),T=r(`, or 
        `),w(P.$$.fragment),W=r("."),J=S("br"),z=S("br"),L=X(),E=S("br"),M=S("br"),U=r(`

        Dictionaries are written as curly braces with zero or more comma-separated key-value pairs inside.
        When compiled, they will become a DiamondFire Dictionary value. The main dictionary will compile differently than normal dictionary values, see above.`),C=S("br"),Y=S("br"),V=r(`

        Valid dictionaries may look like `),w(q.$$.fragment),c=r(", "),w(f.$$.fragment),D=r(`, or
        `),w(G.$$.fragment),H=r(".")},l(u){t=o(u,"DFON has the same two compound types as JSON, dictionaries and lists."),e=A(u,"BR",{}),i=o(u,`
        
        Lists are written as square brackets with zero or more comma-separated values inside. 
        When compiled, they become a DiamondFire List value.`),d=A(u,"BR",{}),b=A(u,"BR",{}),I=o(u,`

        Valid lists may look like `),h(R.$$.fragment,u),y=o(u,", "),h(p.$$.fragment,u),T=o(u,`, or 
        `),h(P.$$.fragment,u),W=o(u,"."),J=A(u,"BR",{}),z=A(u,"BR",{}),L=Z(u),E=A(u,"BR",{}),M=A(u,"BR",{}),U=o(u,`

        Dictionaries are written as curly braces with zero or more comma-separated key-value pairs inside.
        When compiled, they will become a DiamondFire Dictionary value. The main dictionary will compile differently than normal dictionary values, see above.`),C=A(u,"BR",{}),Y=A(u,"BR",{}),V=o(u,`

        Valid dictionaries may look like `),h(q.$$.fragment,u),c=o(u,", "),h(f.$$.fragment,u),D=o(u,`, or
        `),h(G.$$.fragment,u),H=o(u,".")},m(u,O){s(u,t,O),s(u,e,O),s(u,i,O),s(u,d,O),s(u,b,O),s(u,I,O),k(R,u,O),s(u,y,O),k(p,u,O),s(u,T,O),k(P,u,O),s(u,W,O),s(u,J,O),s(u,z,O),s(u,L,O),s(u,E,O),s(u,M,O),s(u,U,O),s(u,C,O),s(u,Y,O),s(u,V,O),k(q,u,O),s(u,c,O),k(f,u,O),s(u,D,O),k(G,u,O),s(u,H,O),Q=!0},p(u,O){const K={};O&1&&(K.$$scope={dirty:O,ctx:u}),R.$set(K);const ne={};O&1&&(ne.$$scope={dirty:O,ctx:u}),p.$set(ne);const x={};O&1&&(x.$$scope={dirty:O,ctx:u}),P.$set(x);const se={};O&1&&(se.$$scope={dirty:O,ctx:u}),q.$set(se);const ee={};O&1&&(ee.$$scope={dirty:O,ctx:u}),f.$set(ee);const m={};O&1&&(m.$$scope={dirty:O,ctx:u}),G.$set(m)},i(u){Q||(v(R.$$.fragment,u),v(p.$$.fragment,u),v(P.$$.fragment,u),v(q.$$.fragment,u),v(f.$$.fragment,u),v(G.$$.fragment,u),Q=!0)},o(u){B(R.$$.fragment,u),B(p.$$.fragment,u),B(P.$$.fragment,u),B(q.$$.fragment,u),B(f.$$.fragment,u),B(G.$$.fragment,u),Q=!1},d(u){u&&(n(t),n(e),n(i),n(d),n(b),n(I),n(y),n(T),n(W),n(J),n(z),n(L),n(E),n(M),n(U),n(C),n(Y),n(V),n(c),n(D),n(H)),N(R,u),N(p,u),N(P,u),N(q,u),N(f,u),N(G,u)}}}function on(a){let t;return{c(){t=r("Documentation")},l(e){t=o(e,"Documentation")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function fn(a){let t,e,i;return e=new Ae({props:{value:`            |{
            |   // This is here for blablabla
            |   someVar: "whatever"
            |
            |   /* 
            |       This next section is here for yada yada yada...
            |       ... remember to blabla! 
            |   */
            |}
        `}}),{c(){t=r(`DFON Files may be documented with comments. The language supports both inline and block comments using traditional C-style comments.
        Inline comments can be started with two slashes, block comments can be started with a slash-star, and ended with a star-slash.

        `),w(e.$$.fragment)},l(d){t=o(d,`DFON Files may be documented with comments. The language supports both inline and block comments using traditional C-style comments.
        Inline comments can be started with two slashes, block comments can be started with a slash-star, and ended with a star-slash.

        `),h(e.$$.fragment,d)},m(d,b){s(d,t,b),k(e,d,b),i=!0},p:Se,i(d){i||(v(e.$$.fragment,d),i=!0)},o(d){B(e.$$.fragment,d),i=!1},d(d){d&&n(t),N(e,d)}}}function mn(a){let t;return{c(){t=r("Macros")},l(e){t=o(e,"Macros")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function pn(a){let t;return{c(){t=r("blockName")},l(e){t=o(e,"blockName")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function un(a){let t;return{c(){t=r("blockName")},l(e){t=o(e,"blockName")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function cn(a){let t;return{c(){t=r("justATwo()")},l(e){t=o(e,"justATwo()")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function _n(a){let t;return{c(){t=r("2")},l(e){t=o(e,"2")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function bn(a){let t;return{c(){t=r("pair(1, 2)")},l(e){t=o(e,"pair(1, 2)")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function gn(a){let t;return{c(){t=r("[1, 2]")},l(e){t=o(e,"[1, 2]")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function dn(a){let t;return{c(){t=r('block("stone", 12)')},l(e){t=o(e,'block("stone", 12)')},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function wn(a){let t;return{c(){t=r('{ blockName: "stone", miningSpeed: 12 }')},l(e){t=o(e,'{ blockName: "stone", miningSpeed: 12 }')},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function hn(a){let t,e,i,d,b,I,R,y,p,T,P,W,J,z,L,E,M,U,C,Y,V,q,c,f,D,G,H,Q,u,O,K,ne,x,se,ee;return b=new Ae({props:{value:`            |macro justATwo() = 2
            |
            |macro pair(x, y) = [x, y]
            |
            |macro block(blockName, blockValue) = {
            |    "blockName": blockName,
            |    "miningSpeed": blockValue    
            |}
        `}}),R=new j({props:{$$slots:{default:[pn]},$$scope:{ctx:a}}}),p=new j({props:{$$slots:{default:[un]},$$scope:{ctx:a}}}),M=new j({props:{$$slots:{default:[cn]},$$scope:{ctx:a}}}),C=new j({props:{$$slots:{default:[_n]},$$scope:{ctx:a}}}),c=new j({props:{$$slots:{default:[bn]},$$scope:{ctx:a}}}),D=new j({props:{$$slots:{default:[gn]},$$scope:{ctx:a}}}),u=new j({props:{$$slots:{default:[dn]},$$scope:{ctx:a}}}),K=new j({props:{$$slots:{default:[wn]},$$scope:{ctx:a}}}),{c(){t=r(`Macros are where DFON strays away from mostly-normal JSON syntax. In any DFON file, any number of macros may be placed above the main dictionary.
        Macros have a name, zero or more named parameters, and a result expression. Both the macro name and parameter names must be valid identifiers.`),e=S("br"),i=S("br"),d=r(`

        Inside macros, parameter names can be used in place of regular values, which will be 
        substituted with the argument supplied to the macro when it is invoked.

        `),w(b.$$.fragment),I=r(`

        Note that in the third macro definition, the `),w(R.$$.fragment),y=r(` key must be written as a string. Otherwise DFON would
        think that you're using the value of the `),w(p.$$.fragment),T=r(" parameter as a dictionary key!"),P=S("br"),W=S("br"),J=r(`

        Assuming these macro definitions are properly above the main dictionary, they can now be invoked in place of a regular value.
        A macro can be invoked by writing its name followed by parenthesis, with comma-separated arguments between the parenthesis.`),z=S("br"),L=S("br"),E=r(`

        With the above code, writing `),w(M.$$.fragment),U=r(" would be the same as writing "),w(C.$$.fragment),Y=r("."),V=S("br"),q=r(`
        Writing `),w(c.$$.fragment),f=r(" would be the same as writing "),w(D.$$.fragment),G=r("."),H=S("br"),Q=r(` 
        Finally, writing `),w(u.$$.fragment),O=r(" is identical to "),w(K.$$.fragment),ne=S("br"),x=S("br"),se=r(`

        Properly using macros can greatly reduce the size of DFON scripts, and improve readability.`)},l(m){t=o(m,`Macros are where DFON strays away from mostly-normal JSON syntax. In any DFON file, any number of macros may be placed above the main dictionary.
        Macros have a name, zero or more named parameters, and a result expression. Both the macro name and parameter names must be valid identifiers.`),e=A(m,"BR",{}),i=A(m,"BR",{}),d=o(m,`

        Inside macros, parameter names can be used in place of regular values, which will be 
        substituted with the argument supplied to the macro when it is invoked.

        `),h(b.$$.fragment,m),I=o(m,`

        Note that in the third macro definition, the `),h(R.$$.fragment,m),y=o(m,` key must be written as a string. Otherwise DFON would
        think that you're using the value of the `),h(p.$$.fragment,m),T=o(m," parameter as a dictionary key!"),P=A(m,"BR",{}),W=A(m,"BR",{}),J=o(m,`

        Assuming these macro definitions are properly above the main dictionary, they can now be invoked in place of a regular value.
        A macro can be invoked by writing its name followed by parenthesis, with comma-separated arguments between the parenthesis.`),z=A(m,"BR",{}),L=A(m,"BR",{}),E=o(m,`

        With the above code, writing `),h(M.$$.fragment,m),U=o(m," would be the same as writing "),h(C.$$.fragment,m),Y=o(m,"."),V=A(m,"BR",{}),q=o(m,`
        Writing `),h(c.$$.fragment,m),f=o(m," would be the same as writing "),h(D.$$.fragment,m),G=o(m,"."),H=A(m,"BR",{}),Q=o(m,` 
        Finally, writing `),h(u.$$.fragment,m),O=o(m," is identical to "),h(K.$$.fragment,m),ne=A(m,"BR",{}),x=A(m,"BR",{}),se=o(m,`

        Properly using macros can greatly reduce the size of DFON scripts, and improve readability.`)},m(m,F){s(m,t,F),s(m,e,F),s(m,i,F),s(m,d,F),k(b,m,F),s(m,I,F),k(R,m,F),s(m,y,F),k(p,m,F),s(m,T,F),s(m,P,F),s(m,W,F),s(m,J,F),s(m,z,F),s(m,L,F),s(m,E,F),k(M,m,F),s(m,U,F),k(C,m,F),s(m,Y,F),s(m,V,F),s(m,q,F),k(c,m,F),s(m,f,F),k(D,m,F),s(m,G,F),s(m,H,F),s(m,Q,F),k(u,m,F),s(m,O,F),k(K,m,F),s(m,ne,F),s(m,x,F),s(m,se,F),ee=!0},p(m,F){const ie={};F&1&&(ie.$$scope={dirty:F,ctx:m}),R.$set(ie);const te={};F&1&&(te.$$scope={dirty:F,ctx:m}),p.$set(te);const le={};F&1&&(le.$$scope={dirty:F,ctx:m}),M.$set(le);const l={};F&1&&(l.$$scope={dirty:F,ctx:m}),C.$set(l);const g={};F&1&&(g.$$scope={dirty:F,ctx:m}),c.$set(g);const ue={};F&1&&(ue.$$scope={dirty:F,ctx:m}),D.$set(ue);const ce={};F&1&&(ce.$$scope={dirty:F,ctx:m}),u.$set(ce);const $e={};F&1&&($e.$$scope={dirty:F,ctx:m}),K.$set($e)},i(m){ee||(v(b.$$.fragment,m),v(R.$$.fragment,m),v(p.$$.fragment,m),v(M.$$.fragment,m),v(C.$$.fragment,m),v(c.$$.fragment,m),v(D.$$.fragment,m),v(u.$$.fragment,m),v(K.$$.fragment,m),ee=!0)},o(m){B(b.$$.fragment,m),B(R.$$.fragment,m),B(p.$$.fragment,m),B(M.$$.fragment,m),B(C.$$.fragment,m),B(c.$$.fragment,m),B(D.$$.fragment,m),B(u.$$.fragment,m),B(K.$$.fragment,m),ee=!1},d(m){m&&(n(t),n(e),n(i),n(d),n(I),n(y),n(T),n(P),n(W),n(J),n(z),n(L),n(E),n(U),n(Y),n(V),n(q),n(f),n(G),n(H),n(Q),n(O),n(ne),n(x),n(se)),N(b,m),N(R,m),N(p,m),N(M,m),N(C,m),N(c,m),N(D,m),N(u,m),N(K,m)}}}function kn(a){let t;return{c(){t=r("Large Example")},l(e){t=o(e,"Large Example")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function vn(a){let t;return{c(){t=r("dirMap")},l(e){t=o(e,"dirMap")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Bn(a){let t;return{c(){t=r("blockData")},l(e){t=o(e,"blockData")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Nn(a){let t,e,i,d,b,I,R,y;return e=new Ae({props:{value:`            |/**
            | * Macro to generate block data.
            | * @param miningTime : number - The number of ticks to mine this block by hand
            | * @param pickaxePower : number - The minimum required pickaxe power to mine this block
            | * @param drops : string[] - List of item IDs this block can drop
            | */
            |macro block(miningTime, pickaxePower, drops) = {
            |    "miningTime": miningTime,
            |    "pickaxePower": pickaxePower,
            |    "drops": drops
            |}
            |
            |
            |
            |// Holds all game data
            |{
            |
            |    // Used for blockdata lookups
            |    dirMap: {
            |        east: < 1,  0,  0>,
            |        west: <-1,  0,  0>,
            |        north: < 0,  0, -1>,
            |        south: < 0,  0,  1>,
            |        up: < 0,  1,  0>,
            |        down: < 0, -1,  0>,
            |    },
            |
            |    // Stores mineable block information
            |    blockData: {
            |              'stone': block(40, 0, ['stone']),
            |           'andesite': block(60, 1, ['stone', 'iron_scrap', 'none']),
            |        'cobblestone': block(80, 2, ['stone', 'gold_scrap', 'none']),
            |    },
            |}
        `}}),d=new j({props:{$$slots:{default:[vn]},$$scope:{ctx:a}}}),I=new j({props:{$$slots:{default:[Bn]},$$scope:{ctx:a}}}),{c(){t=r(`Sometimes it's easier to read through a large example.

        `),w(e.$$.fragment),i=r(`

        This code, when compiled, creates two global variables: `),w(d.$$.fragment),b=r(" and "),w(I.$$.fragment),R=r(".")},l(p){t=o(p,`Sometimes it's easier to read through a large example.

        `),h(e.$$.fragment,p),i=o(p,`

        This code, when compiled, creates two global variables: `),h(d.$$.fragment,p),b=o(p," and "),h(I.$$.fragment,p),R=o(p,".")},m(p,T){s(p,t,T),k(e,p,T),s(p,i,T),k(d,p,T),s(p,b,T),k(I,p,T),s(p,R,T),y=!0},p(p,T){const P={};T&1&&(P.$$scope={dirty:T,ctx:p}),d.$set(P);const W={};T&1&&(W.$$scope={dirty:T,ctx:p}),I.$set(W)},i(p){y||(v(e.$$.fragment,p),v(d.$$.fragment,p),v(I.$$.fragment,p),y=!0)},o(p){B(e.$$.fragment,p),B(d.$$.fragment,p),B(I.$$.fragment,p),y=!1},d(p){p&&(n(t),n(i),n(b),n(R)),N(e,p),N(d,p),N(I,p)}}}function Rn(a){let t;return{c(){t=r("Compilation")},l(e){t=o(e,"Compilation")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Dn(a){let t;return{c(){t=r(`Compiled DFON code will generate one process, and 0 or more functions. All generated templates need to be placed down to work.
        You will need to manually call the process when the first player joins the plot, there is no need to manually call the functions.`)},l(e){t=o(e,`Compiled DFON code will generate one process, and 0 or more functions. All generated templates need to be placed down to work.
        You will need to manually call the process when the first player joins the plot, there is no need to manually call the functions.`)},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Fn(a){let t;return{c(){t=r("Limits")},l(e){t=o(e,"Limits")},m(e,i){s(e,t,i)},d(e){e&&n(t)}}}function Tn(a){let t,e,i,d,b,I,R;return{c(){t=r(`DFON isn't a good fit for every project. Using it means that any time you want to change data, you will need to edit the script,
        recompile the code, and replace the templates. This is made even harder if multiple people are working on your plot.`),e=S("br"),i=S("br"),d=r(`

        The main reasons to use DFON are to make constant data easier to read through and spot bugs with, as well as providing a sort of "backup" in case 
        code is accidentally lost. Constant data is often more devastating to lose than a simple algorithm.`),b=S("br"),I=S("br"),R=r(`

        Feel free to get in contact if you'd like to suggest features or need help making your own PR.
        I am still currently thinking about implementation for function hooks, embedded metadata, support for all DF datatypes, and support for items, among other things.`)},l(y){t=o(y,`DFON isn't a good fit for every project. Using it means that any time you want to change data, you will need to edit the script,
        recompile the code, and replace the templates. This is made even harder if multiple people are working on your plot.`),e=A(y,"BR",{}),i=A(y,"BR",{}),d=o(y,`

        The main reasons to use DFON are to make constant data easier to read through and spot bugs with, as well as providing a sort of "backup" in case 
        code is accidentally lost. Constant data is often more devastating to lose than a simple algorithm.`),b=A(y,"BR",{}),I=A(y,"BR",{}),R=o(y,`

        Feel free to get in contact if you'd like to suggest features or need help making your own PR.
        I am still currently thinking about implementation for function hooks, embedded metadata, support for all DF datatypes, and support for items, among other things.`)},m(y,p){s(y,t,p),s(y,e,p),s(y,i,p),s(y,d,p),s(y,b,p),s(y,I,p),s(y,R,p)},p:Se,d(y){y&&(n(t),n(e),n(i),n(d),n(b),n(I),n(R))}}}function On(a){let t,e,i,d,b,I,R,y,p,T,P,W,J,z,L,E,M,U,C,Y,V,q,c,f,D,G,H,Q,u,O,K,ne,x,se,ee,m,F,ie,te,le;return t=new ft({props:{title:"DiamondFire Object Notation Reference",$$slots:{default:[_t]},$$scope:{ctx:a}}}),i=new _e({props:{$$slots:{default:[dt]},$$scope:{ctx:a}}}),b=new be({props:{$$slots:{default:[wt]},$$scope:{ctx:a}}}),R=new _e({props:{$$slots:{default:[Rt]},$$scope:{ctx:a}}}),p=new be({props:{$$slots:{default:[Dt]},$$scope:{ctx:a}}}),P=new _e({props:{$$slots:{default:[Ut]},$$scope:{ctx:a}}}),J=new be({props:{$$slots:{default:[Yt]},$$scope:{ctx:a}}}),L=new _e({props:{$$slots:{default:[xt]},$$scope:{ctx:a}}}),M=new be({props:{$$slots:{default:[en]},$$scope:{ctx:a}}}),C=new _e({props:{$$slots:{default:[rn]},$$scope:{ctx:a}}}),V=new be({props:{$$slots:{default:[on]},$$scope:{ctx:a}}}),c=new _e({props:{$$slots:{default:[fn]},$$scope:{ctx:a}}}),D=new be({props:{$$slots:{default:[mn]},$$scope:{ctx:a}}}),H=new _e({props:{$$slots:{default:[hn]},$$scope:{ctx:a}}}),u=new be({props:{$$slots:{default:[kn]},$$scope:{ctx:a}}}),K=new _e({props:{$$slots:{default:[Nn]},$$scope:{ctx:a}}}),x=new be({props:{$$slots:{default:[Rn]},$$scope:{ctx:a}}}),ee=new _e({props:{$$slots:{default:[Dn]},$$scope:{ctx:a}}}),F=new be({props:{$$slots:{default:[Fn]},$$scope:{ctx:a}}}),te=new _e({props:{$$slots:{default:[Tn]},$$scope:{ctx:a}}}),{c(){w(t.$$.fragment),e=X(),w(i.$$.fragment),d=X(),w(b.$$.fragment),I=X(),w(R.$$.fragment),y=X(),w(p.$$.fragment),T=X(),w(P.$$.fragment),W=X(),w(J.$$.fragment),z=X(),w(L.$$.fragment),E=X(),w(M.$$.fragment),U=X(),w(C.$$.fragment),Y=X(),w(V.$$.fragment),q=X(),w(c.$$.fragment),f=X(),w(D.$$.fragment),G=X(),w(H.$$.fragment),Q=X(),w(u.$$.fragment),O=X(),w(K.$$.fragment),ne=X(),w(x.$$.fragment),se=X(),w(ee.$$.fragment),m=X(),w(F.$$.fragment),ie=X(),w(te.$$.fragment)},l(l){h(t.$$.fragment,l),e=Z(l),h(i.$$.fragment,l),d=Z(l),h(b.$$.fragment,l),I=Z(l),h(R.$$.fragment,l),y=Z(l),h(p.$$.fragment,l),T=Z(l),h(P.$$.fragment,l),W=Z(l),h(J.$$.fragment,l),z=Z(l),h(L.$$.fragment,l),E=Z(l),h(M.$$.fragment,l),U=Z(l),h(C.$$.fragment,l),Y=Z(l),h(V.$$.fragment,l),q=Z(l),h(c.$$.fragment,l),f=Z(l),h(D.$$.fragment,l),G=Z(l),h(H.$$.fragment,l),Q=Z(l),h(u.$$.fragment,l),O=Z(l),h(K.$$.fragment,l),ne=Z(l),h(x.$$.fragment,l),se=Z(l),h(ee.$$.fragment,l),m=Z(l),h(F.$$.fragment,l),ie=Z(l),h(te.$$.fragment,l)},m(l,g){k(t,l,g),s(l,e,g),k(i,l,g),s(l,d,g),k(b,l,g),s(l,I,g),k(R,l,g),s(l,y,g),k(p,l,g),s(l,T,g),k(P,l,g),s(l,W,g),k(J,l,g),s(l,z,g),k(L,l,g),s(l,E,g),k(M,l,g),s(l,U,g),k(C,l,g),s(l,Y,g),k(V,l,g),s(l,q,g),k(c,l,g),s(l,f,g),k(D,l,g),s(l,G,g),k(H,l,g),s(l,Q,g),k(u,l,g),s(l,O,g),k(K,l,g),s(l,ne,g),k(x,l,g),s(l,se,g),k(ee,l,g),s(l,m,g),k(F,l,g),s(l,ie,g),k(te,l,g),le=!0},p(l,g){const ue={};g&1&&(ue.$$scope={dirty:g,ctx:l}),t.$set(ue);const ce={};g&1&&(ce.$$scope={dirty:g,ctx:l}),i.$set(ce);const $e={};g&1&&($e.$$scope={dirty:g,ctx:l}),b.$set($e);const ge={};g&1&&(ge.$$scope={dirty:g,ctx:l}),R.$set(ge);const de={};g&1&&(de.$$scope={dirty:g,ctx:l}),p.$set(de);const we={};g&1&&(we.$$scope={dirty:g,ctx:l}),P.$set(we);const he={};g&1&&(he.$$scope={dirty:g,ctx:l}),J.$set(he);const ae={};g&1&&(ae.$$scope={dirty:g,ctx:l}),L.$set(ae);const ke={};g&1&&(ke.$$scope={dirty:g,ctx:l}),M.$set(ke);const re={};g&1&&(re.$$scope={dirty:g,ctx:l}),C.$set(re);const ve={};g&1&&(ve.$$scope={dirty:g,ctx:l}),V.$set(ve);const oe={};g&1&&(oe.$$scope={dirty:g,ctx:l}),c.$set(oe);const Be={};g&1&&(Be.$$scope={dirty:g,ctx:l}),D.$set(Be);const Ne={};g&1&&(Ne.$$scope={dirty:g,ctx:l}),H.$set(Ne);const fe={};g&1&&(fe.$$scope={dirty:g,ctx:l}),u.$set(fe);const Re={};g&1&&(Re.$$scope={dirty:g,ctx:l}),K.$set(Re);const me={};g&1&&(me.$$scope={dirty:g,ctx:l}),x.$set(me);const De={};g&1&&(De.$$scope={dirty:g,ctx:l}),ee.$set(De);const pe={};g&1&&(pe.$$scope={dirty:g,ctx:l}),F.$set(pe);const Fe={};g&1&&(Fe.$$scope={dirty:g,ctx:l}),te.$set(Fe)},i(l){le||(v(t.$$.fragment,l),v(i.$$.fragment,l),v(b.$$.fragment,l),v(R.$$.fragment,l),v(p.$$.fragment,l),v(P.$$.fragment,l),v(J.$$.fragment,l),v(L.$$.fragment,l),v(M.$$.fragment,l),v(C.$$.fragment,l),v(V.$$.fragment,l),v(c.$$.fragment,l),v(D.$$.fragment,l),v(H.$$.fragment,l),v(u.$$.fragment,l),v(K.$$.fragment,l),v(x.$$.fragment,l),v(ee.$$.fragment,l),v(F.$$.fragment,l),v(te.$$.fragment,l),le=!0)},o(l){B(t.$$.fragment,l),B(i.$$.fragment,l),B(b.$$.fragment,l),B(R.$$.fragment,l),B(p.$$.fragment,l),B(P.$$.fragment,l),B(J.$$.fragment,l),B(L.$$.fragment,l),B(M.$$.fragment,l),B(C.$$.fragment,l),B(V.$$.fragment,l),B(c.$$.fragment,l),B(D.$$.fragment,l),B(H.$$.fragment,l),B(u.$$.fragment,l),B(K.$$.fragment,l),B(x.$$.fragment,l),B(ee.$$.fragment,l),B(F.$$.fragment,l),B(te.$$.fragment,l),le=!1},d(l){l&&(n(e),n(d),n(I),n(y),n(T),n(W),n(z),n(E),n(U),n(Y),n(q),n(f),n(G),n(Q),n(O),n(ne),n(se),n(m),n(ie)),N(t,l),N(i,l),N(b,l),N(R,l),N(p,l),N(P,l),N(J,l),N(L,l),N(M,l),N(C,l),N(V,l),N(c,l),N(D,l),N(H,l),N(u,l),N(K,l),N(x,l),N(ee,l),N(F,l),N(te,l)}}}function yn(a){let t,e,i,d;return t=new at({props:{title:"DFON - Reference",desc:"Reference page for the DFON markup language."}}),i=new ot({props:{$$slots:{default:[On]},$$scope:{ctx:a}}}),{c(){w(t.$$.fragment),e=X(),w(i.$$.fragment)},l(b){h(t.$$.fragment,b),e=Z(b),h(i.$$.fragment,b)},m(b,I){k(t,b,I),s(b,e,I),k(i,b,I),d=!0},p(b,[I]){const R={};I&1&&(R.$$scope={dirty:I,ctx:b}),i.$set(R)},i(b){d||(v(t.$$.fragment,b),v(i.$$.fragment,b),d=!0)},o(b){B(t.$$.fragment,b),B(i.$$.fragment,b),d=!1},d(b){b&&n(e),N(t,b),N(i,b)}}}class Ln extends et{constructor(t){super(),tt(this,t,null,yn,xe,{})}}export{Ln as component};
